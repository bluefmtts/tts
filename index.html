import os
import sys
import nest_asyncio
import json
import time
import asyncio
import aiohttp
import requests
from dotenv import load_dotenv
from flask import Flask, request, jsonify
import threading
from datetime import datetime
import traceback

# Apply nest_asyncio FIRST
nest_asyncio.apply()

# Force compatibility
import warnings
warnings.filterwarnings("ignore", category=SyntaxWarning)

try:
    from telegram import Bot
    print("‚úÖ All imports successful!")
except ImportError as e:
    print(f"‚ùå Import Error: {e}")
    sys.exit(1)

# Flask app setup
app = Flask(__name__)

@app.route('/')
def home():
    return "üéµ Multi-Bot TTS Service - Webhook Mode Active (2 Bots Configured)"

@app.route('/health')
def health():
    return {"status": "healthy", "timestamp": datetime.now().isoformat(), "bots": 2}, 200

# üî• Webhook endpoint for Firebase
@app.route('/webhook', methods=['POST'])
def webhook():
    """Handle webhook from Firebase with dynamic bot support"""
    try:
        data = request.get_json()
        print("üì® Received webhook data:", json.dumps(data, indent=2))
        
        # Extract bot token and user info from request
        bot_token = data.get('botToken')
        user_id = data.get('userId')
        user_email = data.get('userEmail')
        
        if not bot_token:
            return jsonify({"error": "Bot token not provided"}), 400
        
        # Log which bot is being used
        bot_info = "Unknown Bot"
        if "kd2U6Bk1OU1l1uLNIBQAQ_9gIH5qLI" in bot_token:
            bot_info = "@Myttsmasterbot (Bot1)"
        elif "AAGKEb19mjeBVo4r-HGpmKydPQIOstHuoCQ" in bot_token:
            bot_info = "@g080ydbot (Bot2)"
        
        print(f"ü§ñ Using bot: {bot_info} for user: {user_email}")
        
        # Process the webhook data
        if data and 'message' in data:
            # Extract command and parameters
            message = data.get('message', {})
            text = message.get('text', '')
            
            if text.startswith('/process'):
                print(f"üîÑ Processing webhook command for user {user_email} with {bot_info}: {text}")
                
                # Run async handler in thread with specific bot token
                def process_update():
                    try:
                        # Create bot instance with user's specific token
                        user_bot = Bot(token=bot_token)
                        
                        # Process the command with user's bot
                        asyncio.run(handle_process_command_webhook(
                            user_bot, 
                            message, 
                            text, 
                            user_id, 
                            user_email,
                            bot_token,
                            bot_info
                        ))
                        
                    except Exception as e:
                        print(f"‚ùå Webhook processing error for user {user_email}: {e}")
                        traceback.print_exc()
                
                # Run in background thread
                thread = threading.Thread(target=process_update)
                thread.daemon = True
                thread.start()
                
                return jsonify({
                    "status": "success", 
                    "message": "Processing started",
                    "user": user_email,
                    "bot": bot_info
                }), 200
            else:
                return jsonify({"error": "Invalid command"}), 400
        else:
            return jsonify({"error": "Invalid data format"}), 400
            
    except Exception as e:
        print(f"‚ùå Webhook error: {e}")
        traceback.print_exc()
        return jsonify({"error": str(e)}), 500

def run_flask():
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=False, use_reloader=False)

# Load environment variables
load_dotenv()

# üî• UPDATED BOT URLs - Both bots supported
BOT_URL = os.getenv('BOT_URL', 'https://onetts-tuc2.onrender.com')  # Updated URL

# üî• Firebase Configuration
FIREBASE_PROJECT_ID = os.getenv('FIREBASE_PROJECT_ID', 'bluefm-tts')
FIREBASE_FUNCTION_URL = f'https://us-central1-{FIREBASE_PROJECT_ID}.cloudfunctions.net'

print(f"üîë Bot URL: {BOT_URL}")
print(f"üîë Firebase Project: {FIREBASE_PROJECT_ID}")
print(f"üîë Firebase Function URL: {FIREBASE_FUNCTION_URL}")
print(f"ü§ñ Supporting 2 bots:")
print(f"   üì± Bot1: @Myttsmasterbot")
print(f"   üì± Bot2: @g080ydbot")

# Bot instances cache (optional, for performance)
BOT_CACHE = {}

def get_or_create_bot(bot_token):
    """Get bot instance from cache or create new one"""
    if bot_token not in BOT_CACHE:
        BOT_CACHE[bot_token] = Bot(token=bot_token)
    return BOT_CACHE[bot_token]

# ==================== WEBHOOK SPECIFIC FUNCTIONS ====================
async def handle_process_command_webhook(bot, message_data, text, user_id, user_email, bot_token, bot_info):
    """Handle /process command from Firebase webhook with user-specific bot"""
    try:
        parts = text.split()
        if len(parts) < 4:
            print("‚ùå Invalid process command format")
            return
        
        text_url = parts[1]
        audio_url = parts[2] 
        job_id = parts[3]
        
        chat_id = message_data.get('chat', {}).get('id')
        
        print(f"üîÑ Processing webhook for {user_email} with {bot_info}: text={text_url}, audio={audio_url}, job={job_id}")
        
        # Send processing message using user's bot
        await bot.send_message(
            chat_id=chat_id,
            text=f"üöÄ Firebase request received!\n"
                 f"üë§ User: {user_email}\n"
                 f"ü§ñ Bot: {bot_info}\n"
                 f"üìù Job ID: {job_id}\n"
                 f"üîÑ Files received from Firebase..."
        )
        
        # Send notification about the files received
        await bot.send_message(
            chat_id=chat_id,
            text=f"‚úÖ Files received successfully!\n"
                 f"üìÑ Text file URL: {text_url}\n"
                 f"üéµ Audio file URL: {audio_url}\n"
                 f"üìù Job ID: {job_id}\n"
                 f"üë§ User: {user_email} ({user_id})\n"
                 f"ü§ñ Using {bot_info} for this user\n\n"
                 f"üö´ No further processing (Kaggle disabled)"
        )
        
        # Send status back to Firebase with user info
        await send_status_to_firebase(job_id, "received", "Files received on Telegram", user_id, user_email)
        
    except Exception as e:
        print(f"‚ùå Process command error for {user_email}: {e}")
        traceback.print_exc()
        if 'chat_id' in locals():
            try:
                await bot.send_message(chat_id=chat_id, text=f"‚ùå Processing error: {str(e)}")
                await send_status_to_firebase(job_id, "failed", str(e), user_id, user_email)
            except:
                pass

# üî• Function to send status to Firebase
async def send_status_to_firebase(job_id, status, details="", user_id="", user_email=""):
    """Send processing status back to Firebase with user info"""
    try:
        data = {
            "userId": user_id,
            "userEmail": user_email,
            "jobId": str(job_id),
            "status": status,
            "details": details,
            "timestamp": datetime.now().isoformat()
        }
        
        if status == "failed":
            data["error"] = details
        
        firebase_status_url = f"{FIREBASE_FUNCTION_URL}/updateJobStatus"
        
        async with aiohttp.ClientSession() as session:
            async with session.post(
                firebase_status_url, 
                json=data, 
                headers={"Content-Type": "application/json"},
                timeout=30
            ) as resp:
                if resp.status == 200:
                    print(f"‚úÖ Status sent to Firebase for {user_email}: {status}")
                else:
                    print(f"‚ùå Firebase webhook failed for {user_email}: {resp.status}")
                    
    except Exception as e:
        print(f"‚ùå Error sending to Firebase: {e}")

# ==================== MAIN FUNCTION ====================
def main():
    """Main function to start the multi-bot service"""
    print("üöÄ Starting Multi-Bot TTS Service...")
    print("ü§ñ Dynamic bot assignment enabled!")
    print("‚úÖ Supporting 2 users with 2 bots!")
    print("üì± Bot1: @Myttsmasterbot for vikassingh44999@gmail.com")
    print("üì± Bot2: @g080ydbot for god662135@gmail.com")
    
    # Start Flask server
    flask_thread = threading.Thread(target=run_flask)
    flask_thread.daemon = True
    flask_thread.start()
    print("üåê Flask webhook server started!")

    print("üöÄ Multi-Bot Service Started!")
    print("ü§ñ WEBHOOK-ONLY MODE!")
    print("‚úÖ FIREBASE TO TELEGRAM: ENABLED")
    print(f"üîó Webhook URL: {BOT_URL}/webhook")
    print(f"üî• Firebase Function URL: {FIREBASE_FUNCTION_URL}")
    print("üë• Supporting 2 users with individual bots!")

    # Keep Flask running
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("üõë Bot service stopped")

if __name__ == "__main__":
    main()
